<#@ template debug="true" hostSpecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ parameter name="classType" type="System.Type" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="System.Reflection" #>
<#@ import namespace="UnityEngine" #>
<#@ assembly name="$(SolutionDir)JiffyEditor\bin\Debug\UnityEditor.dll" #>
<#@ assembly name="$(SolutionDir)JiffyEditor\bin\Debug\UnityEngine.dll" #>
<#@ assembly name="$(SolutionDir)JiffyEditor\bin\Debug\JiffyEditor.dll" #>
<#@ include file="$(SolutionDir)JiffyEditor\Jiffy\LayoutTypes\Simple.tt"#>
<#@ include file="$(SolutionDir)JiffyEditor\Jiffy\SharedData.tt"#>
<# PopulateClass(); #>
<#+ 

 public void PopulateClass()
{
  SharedData sharedData = new SharedData(typeof(Family), indent:"  ");

  WriteLine("using UnityEditor;");
  WriteLine("using UnityEngine;");
  WriteLine("[CustomEditor(typeof(" + sharedData.className + "))]");
  WriteLine("public class " + sharedData.className + "Editor : Editor");
  WriteLine("{");
  PushIndent(sharedData.indent); 

  //Get all it's fields
  FieldInfo[] fields = sharedData.classType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
  
  UnityFieldInfo master = new UnityFieldInfo(null, "OOO");
  
  for(int i = 0; i < fields.Length; i++)
  {
      UnityFieldInfo info = new UnityFieldInfo(fields[i]);
  
      master.AddChild(info);
  
      GetFieldInfo(info);
  }
  
  PushIndent(sharedData.indent);

  //Simple
  //CreateSimpleEditor(master,sharedData);

  //Deep Nested
  //DrawDeepNestedClass(master, sharedData);

  //OuputWriters();

  PopIndent();

  PushIndent(sharedData.indent);

#region -= Function OnEnable =-
#>

/// <summary>
/// OnEnable is called by Unity every time you look at the
/// Inspector. In this function we setup all our serialized 
/// values. 
/// </summary><#+
  WriteLine(""); //Add a space between functions
  WriteLine("public void OnEnable()");
  WriteLine("{");
  PushIndent(sharedData.indent);
  for(int i = 0; i < master.childCount; i++)
  {
    if(master[i].childCount == 0)
    {
      WriteLine(master[i].field.Name + " = serializedObject.FindProperty(\"" + master[i].field.Name + "\");");
    }
    else
    {
      WriteLine(master[i].field.Name + " = new " + master[i].field.FieldType.Name + "(serializedObject.FindProperty(\"" + master[i].field.Name + "\"));");
    }
  }
  PopIndent();
  WriteLine("}");
#endregion 
#region -= Function OnInspectorGUI =-
#>

/// <summary>
/// Inside this function you can add your own custom GUI for the 
/// inspector of a specific object class. The one provided will
/// draw the class to look like the default inspector.
/// </summary><#+
  WriteLine(""); //Add a space between functions
  WriteLine("public override void OnInspectorGUI()");
  WriteLine("{");
  PushIndent(sharedData.indent);
  for(int i = 0; i < master.childCount; i++)
  {
    if(master[i].childCount == 0)
    {
      WriteLine("EditorGUILayout.PropertyField(" + master[i].field.Name + ");");
    }
    else
    {
      WriteLine("EditorGUILayout.PropertyField(" + master[i].field.Name + ".value, true);");
    }
  }
  PopIndent();
  WriteLine("}");
  PopIndent();
#endregion 
  PopIndent();

  WriteLine("}");
}#>
<#+ 
public void GetFieldInfo(UnityFieldInfo info)
{
    //We chake to make sure that our class is public or private and serializeable
    if(!info.field.IsPublic && Attribute.GetCustomAttribute(info.field, typeof(UnityEngine.SerializeField)) == null)
    {
     //None of these so we can't do anything here
      return; 
    }

    //now filter out base types
    Type t =  info.field.FieldType;

    if(t == typeof(int) || 
       t == typeof(float) || 
       t == typeof(bool) ||
       t == typeof(string) || 
       t == typeof(char) ||
       t == typeof(long))
    {
        return;
    }

    //now filter out Unity types
    if(t == typeof(Vector2) || 
       t == typeof(Vector3) || 
       t == typeof(Vector4) || 
       t == typeof(Transform) || 
       t == typeof(GameObject) ||
       t == typeof(Bounds) ||
       t == typeof(Color))
    {
       return; 
    }

    //Get all it's fields
    FieldInfo[] fields = info.field.FieldType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

    if(fields.Length == 0)
    {
        return; 
    }

    for(int i = 0; i < fields.Length; i++)
    {
        UnityFieldInfo childInfo = new UnityFieldInfo(fields[i]);
        info.AddChild(childInfo);
    
        GetFieldInfo(childInfo);
    }
   }
#>
